#!/usr/bin/env python3

# contrastAnalysis.py
# Script for analyzing simulated "microscopy" images generated by active-microemulsion
#

import argparse
import os

import cv2
import numpy as np

from utilsLib import Plotter, computeCov, getEntryNearestToValue, FileSequence, CsvWriter


class Analysis:
    def __init__(self, fileSequence, blurRadius=3, quiet=False):
        self.fileSequence = fileSequence
        self.blurRadius = blurRadius
        self.quiet = quiet
        self.deltaT = 1
        self.skip = 0
        self.resultsKeys = ['SnapshotNumber', 'CoV', 'MeanIntensity']
        self.results = []  # List of [snapshotNumber, CoV, meanIntensity] elements
        self.resultMatrix = None  # This will contain the numpy.ndarray of the results for easy slicing
        self.resultDict = {"id": [], "cov": [], "meanIntensity": []}
        self.__analyzeSequence(self.fileSequence)
        self.numSamples = len(self.results)

    def __analyzeSnapshot(self, snapshotNum, snapshotFile):
        img = cv2.imread(snapshotFile.getName())
        if type(img) == type(None):
            print("WARNING: Image %s cannot be read. Ignoring it." % (snapshotFile))
            return
        blurredImg = cv2.GaussianBlur(img, (self.blurRadius, self.blurRadius), 0)
        cov, mean = computeCov(blurredImg)
        self.results.append([snapshotNum, cov, mean])
        if not self.quiet:
            print("> %s : CoV = %f, meanIntensity = %f" % (os.path.basename(snapshotFile), cov, mean))

    def __analyzeSequence(self, fileSequence):
        for id, item in enumerate(fileSequence):
            self.__analyzeSnapshot(id, item)
        self.resultMatrix = np.array(self.results)
        self.resultDict["id"] = list(self.resultMatrix[:, 0])
        self.resultDict["cov"] = list(self.resultMatrix[:, 1])
        self.resultDict["meanIntensity"] = list(self.resultMatrix[:, 2])

    @staticmethod
    def computeMovingAverage(sequence, windowSize):
        return np.convolve(sequence, np.ones((windowSize,)) / windowSize, mode='valid')

    def setSkip(self, skip=0):
        """
        Set the number of initial entries to skip when getting the results.
        :param skip: Positive integer
        :return: None
        """
        self.skip = skip

    def setDeltaT(self, deltaT=1):
        """
        Set the time mapping corresponding to a single timestep.
        :param deltaT: Positive integer
        :return: None
        """
        self.deltaT = deltaT

    def getNumSamples(self):
        return self.numSamples

    def getX(self):
        return [self.deltaT * x for x in self.resultDict["id"][self.skip:]]

    def getCov(self):
        return self.resultDict["cov"][self.skip:]

    def getMeanIntensity(self):
        return self.resultDict["meanIntensity"][self.skip:]


if __name__ == "__main__":
    # Manage command line arguments
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("inputFiles", help="The image file to perform measurements on", nargs='+')
    parser.add_argument("-b", "--blur-radius", help="Radius of gaussian blur", dest="blurRadius", type=int, default=3)
    parser.add_argument("-m", "--moving-average-window",
                        help="Length of the moving average window. NOTE: It must be an ODD number",
                        dest="movingAvgWindow", type=int, default=7)
    parser.add_argument("-t", "--time-mapping", help="Time interval between snapshots", dest="deltaT", type=float,
                        default=1)
    parser.add_argument("-c", "--cutoff-time", help="Time point at which a generic cutoff took place", dest="cutoff",
                        type=float,
                        default=-1)
    parser.add_argument("--flavopiridol", help="Time point at which Flavopiridol was applied", dest="flavopiridol",
                        type=float,
                        default=-1)
    parser.add_argument("--actinomycin-D", help="Time point at which Actinomycin D was applied", dest="actinomycinD",
                        type=float,
                        default=-1)
    parser.add_argument("--activate", help="Time point at which transcription is activated", dest="activate",
                        type=float,
                        default=-1)
    parser.add_argument("-p", "--plot", help="Name of the desired output file for the generated plot",
                        dest="plotFileName", default="contrastAnalysis_plot.svg")
    parser.add_argument("-d", "--csv", help="Name of the desired output csv for the data",
                        dest="csvFileName", default="contrastAnalysis_results.csv")
    parser.add_argument("-s", "--script-mode", help="Run non-interactive. For embedding into scripts.",
                        dest="scriptMode", action='store_true')

    args = parser.parse_args()
    # Extract the base directory, so that we can by default save plot and data there
    inputDirectory = os.path.dirname(args.inputFiles[0])

    # Using input dir for plot if none was explicitly passed
    plotDirectory, plotFilename = os.path.split(args.plotFileName)
    if not plotDirectory:
        plotDirectory = inputDirectory
    args.plotFileName = os.path.join(plotDirectory, plotFilename)

    # Using input dir for csv if none was explicitly passed
    csvDirectory, csvFilename = os.path.split(args.csvFileName)
    if not csvDirectory:
        csvDirectory = inputDirectory
    args.csvFileName = os.path.join(csvDirectory, csvFilename)

    # Expanding and sorting the file list
    fileSequence = FileSequence(args.inputFiles)

    # Perform the actual analysis
    analysis = Analysis(fileSequence, blurRadius=args.blurRadius, quiet=args.scriptMode)
    analysis.setSkip(1)
    analysis.setDeltaT(args.deltaT)

    # Write analysis data to CSV
    CsvWriter(analysis.resultsKeys, analysis.results).write(args.csvFileName)

    # Moving average
    maWindow = args.movingAvgWindow  # Must be an odd number
    MA = Analysis.computeMovingAverage(analysis.getCov(), maWindow)
    # Find argmax of the moving average
    argmaxMA = np.argmax(MA)
    offsetMA = int((maWindow - 1) / 2)

    # Plotting
    plotter = Plotter(analysis.getX(), plotFileName=args.plotFileName,
                      xlabel="Time", ylabel="CoV",
                      interactive=(not args.scriptMode))
    plotter.addYSeries(analysis.getCov())
    plotter.addYSeries(MA, offsetMA)
    # Annotation
    maxMA = MA[argmaxMA]
    maxCovX = (analysis.skip + offsetMA + argmaxMA) * analysis.deltaT
    plotter.ax.annotate('Maximum CoV @ t=%d' % (maxCovX),
                        xy=(maxCovX, maxMA + 0.03 * plotter.plotHeight),
                        xytext=(maxCovX - 10 * analysis.deltaT, maxMA + 0.2 * plotter.plotHeight),
                        arrowprops=dict(facecolor='red', shrink=1))
    activateTime = args.activate
    if activateTime > 0:
        nearestTimeToActivation = getEntryNearestToValue(analysis.getX(), activateTime)
        # nearestValueToCutoff = analysis.getCov()[analysis.getX().index(nearestTimeToCutoff)]
        nearestValueToActivation = MA[analysis.getX().index(nearestTimeToActivation) - offsetMA]
        plotter.ax.annotate('Transcription ON @ x=%d' % (activateTime),
                            xy=(activateTime, nearestValueToActivation + 0.03 * plotter.plotHeight),
                            xytext=(
                                activateTime - 10 * analysis.deltaT,
                                nearestValueToActivation + 0.2 * plotter.plotHeight),
                            arrowprops=dict(facecolor='black', shrink=1))

    for event in ["flavopiridol", "actinomycinD"]:
        eventTime = getattr(args, event)
        if eventTime > 0:
            nearestTimeToEvent = getEntryNearestToValue(analysis.getX(), eventTime)
            # nearestValueToCutoff = analysis.getCov()[analysis.getX().index(nearestTimeToCutoff)]
            nearestValueToEvent = MA[analysis.getX().index(nearestTimeToEvent) - offsetMA]
            plotter.ax.annotate('%s @ t=%d' % (event.capitalize(), eventTime),
                                xy=(eventTime, nearestValueToEvent - 0.03 * plotter.plotHeight),
                                xytext=(
                                    eventTime - 10 * analysis.deltaT, nearestValueToEvent - 0.2 * plotter.plotHeight),
                                arrowprops=dict(facecolor='green', shrink=1))

    cutoffTime = args.cutoff
    if cutoffTime > 0:
        nearestTimeToCutoff = getEntryNearestToValue(analysis.getX(), cutoffTime)
        # nearestValueToCutoff = analysis.getCov()[analysis.getX().index(nearestTimeToCutoff)]
        nearestValueToCutoff = MA[analysis.getX().index(nearestTimeToCutoff) - offsetMA]
        plotter.ax.annotate('Cutoff @ t=%d' % (cutoffTime),
                            xy=(cutoffTime, nearestValueToCutoff - 0.03 * plotter.plotHeight),
                            xytext=(cutoffTime - 10, nearestValueToCutoff - 0.2 * plotter.plotHeight),
                            arrowprops=dict(facecolor='green', shrink=1))
    plotter.plot()

    print("Plot saved at %s" % (args.plotFileName))
    print("Data saved at %s" % (args.csvFileName))
# eof
